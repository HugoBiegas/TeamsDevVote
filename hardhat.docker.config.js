require("@nomicfoundation/hardhat-toolbox");
const { task } = require("hardhat/config");

/** @type import('hardhat/config').HardhatUserConfig */
module.exports = {
  solidity: {
    version: "0.8.19",
    settings: {
      optimizer: {
        enabled: true,
        runs: 200,
      },
      viaIR: false, // Optimisation pour Docker
    },
  },
  
  // PAS de defaultNetwork d√©fini - Hardhat utilise automatiquement "hardhat"
  
  networks: {
    // Configuration par d√©faut Hardhat (r√©seau int√©gr√©) - Optimis√© Docker
    hardhat: {
      chainId: 31337,
      accounts: {
        mnemonic: "test test test test test test test test test test test junk",
        count: 20,
        accountsBalance: "10000000000000000000000", // 10000 ETH
      },
      gas: "auto",
      gasPrice: "auto",
      blockGasLimit: 30000000,
      allowUnlimitedContractSize: process.env.NODE_ENV !== "production",
      mining: {
        auto: true,
        interval: process.env.MINING_INTERVAL || 0,
      },
    },
    
    // Configuration pour connexion externe au n≈ìud local qui tourne
    localhost: {
      url: "http://127.0.0.1:8545",
      chainId: 31337,
      timeout: 60000,
      httpHeaders: {
        "User-Agent": "Hardhat-Docker-Client"
      },
    },
    
    // Configuration pour Docker (communication inter-conteneurs) - PRINCIPAL
    docker: {
      url: "http://hardhat-dev:8545",
      chainId: 31337,
      timeout: 60000,
      httpHeaders: {
        "User-Agent": "Hardhat-Docker-Internal"
      },
    },
    
    // Configuration pour Ganache dans Docker
    ganache: {
      url: "http://ganache:8545",
      accounts: {
        mnemonic: "test test test test test test test test test test test junk"
      },
      chainId: 1337,
      gas: 6721975,
      gasPrice: 20000000000,
      timeout: 60000,
    },
    
    // Configuration pour les r√©seaux externes via Docker
    sepolia: {
      url: process.env.SEPOLIA_URL || "",
      accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : [],
      chainId: 11155111,
      timeout: 60000,
    },
    
    mainnet: {
      url: process.env.MAINNET_URL || "",
      accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : [],
      chainId: 1,
      gas: "auto",
      gasPrice: "auto",
      timeout: 120000, // Plus long pour mainnet
    },
  },
  
  // Configuration des chemins optimis√©e pour Docker
  paths: {
    sources: "./contracts",
    tests: "./test",
    cache: "./cache",
    artifacts: "./artifacts"
  },
  
  // Configuration Mocha pour les tests avec timeout adapt√© Docker
  mocha: {
    timeout: 120000, // Plus long pour Docker
    retries: 2, // Retry en cas d'√©chec r√©seau
  },
  
  // Configuration du gas reporter (optionnel)
  gasReporter: {
    enabled: process.env.REPORT_GAS !== undefined,
    currency: "USD",
    outputFile: "gas-report.txt",
    noColors: true,
  },
  
  // Configuration de Etherscan (pour la v√©rification)
  etherscan: {
    apiKey: {
      mainnet: process.env.ETHERSCAN_API_KEY || "",
      sepolia: process.env.ETHERSCAN_API_KEY || "",
    }
  },
  
  // Configuration sp√©cifique Docker
  docker: {
    // Configuration pour le healthcheck
    healthcheck: {
      enabled: true,
      interval: 30000,
      timeout: 10000,
      retries: 3,
    },
    
    // Configuration des logs
    logging: {
      level: process.env.LOG_LEVEL || "info",
      format: "json",
    },
  },
  
  // Configuration de s√©curit√© pour Docker
  security: {
    // D√©sactiver les fonctions dangereuses en production
    allowUnlimitedContractSize: process.env.NODE_ENV !== "production",
    
    // Configuration du mining interval pour les tests
    mining: {
      auto: true,
      interval: process.env.MINING_INTERVAL || 0,
    },
  },
};

// ===============================================
// COMMANDES PR√âFAITES POUR VOTER - VERSION DOCKER
// ===============================================

// Commande pour voter rapidement - Optimis√©e Docker
task("vote", "Vote pour un candidat")
  .addParam("candidate", "Index du candidat (0=Alice, 1=Bob, 2=Carol)")
  .addOptionalParam("contract", "Adresse du contrat", "")
  .addOptionalParam("network", "R√©seau √† utiliser", "hardhat")
  .setAction(async (taskArgs, hre) => {
    console.log(`üê≥ Mode Docker - R√©seau: ${taskArgs.network}`);
    
    const [signer] = await hre.ethers.getSigners();
    
    let contractAddress = taskArgs.contract;
    
    // Si pas d'adresse fournie, d√©ployer un nouveau contrat
    if (!contractAddress) {
      console.log("üì¶ D√©ploiement d'un nouveau contrat...");
      const Voting = await hre.ethers.getContractFactory("Voting");
      const voting = await Voting.deploy(["Alice", "Bob", "Carol"]);
      await voting.waitForDeployment();
      contractAddress = await voting.getAddress();
      console.log("‚úÖ Contrat d√©ploy√©:", contractAddress);
      console.log("üê≥ R√©seau utilis√©:", hre.network.name);
    }
    
    // Se connecter au contrat
    const voting = await hre.ethers.getContractAt("Voting", contractAddress);
    
    // Voter
    const candidateIndex = parseInt(taskArgs.candidate);
    const candidateNames = ["Alice", "Bob", "Carol"];
    
    if (candidateIndex < 0 || candidateIndex >= candidateNames.length) {
      console.log("‚ùå Index invalide! Utilisez 0=Alice, 1=Bob, 2=Carol");
      return;
    }
    
    console.log(`üó≥Ô∏è  Vote pour ${candidateNames[candidateIndex]} (index ${candidateIndex})`);
    console.log(`üë§ √âlecteur: ${signer.address}`);
    console.log(`üåê R√©seau: ${hre.network.name} (${hre.network.config.chainId})`);
    
    try {
      // Gas estimation pour Docker
      const gasEstimate = await voting.vote.estimateGas(candidateIndex);
      console.log(`‚õΩ Gas estim√©: ${gasEstimate.toString()}`);
      
      const tx = await voting.vote(candidateIndex, {
        gasLimit: gasEstimate * 120n / 100n // 20% de marge
      });
      
      console.log("‚è≥ Transaction envoy√©e, attente de confirmation...");
      const receipt = await tx.wait();
      
      console.log("‚úÖ Vote enregistr√©!");
      console.log("üìç Transaction:", tx.hash);
      console.log("üßÆ Gas utilis√©:", receipt.gasUsed.toString());
      console.log("üß± Bloc:", receipt.blockNumber);
      
    } catch (error) {
      if (error.message.includes("Already voted")) {
        console.log("‚ùå Cette adresse a d√©j√† vot√©!");
      } else if (error.message.includes("Invalid candidate")) {
        console.log("‚ùå Candidat invalide!");
      } else if (error.code === 'NETWORK_ERROR') {
        console.log("‚ùå Erreur r√©seau Docker. V√©rifiez que le n≈ìud Hardhat fonctionne.");
        console.log("üí° Essayez: docker-compose ps | grep hardhat-dev");
      } else {
        console.log("‚ùå Erreur:", error.message);
      }
      return;
    }
    
    // Afficher les r√©sultats actuels
    try {
      const results = await voting.getCandidates();
      console.log("\nüìä R√©sultats actuels:");
      results[0].forEach((name, i) => {
        console.log(`   ${name}: ${results[1][i]} votes`);
      });
      
      const winner = await voting.getWinner();
      console.log(`\nüèÜ Gagnant actuel: ${winner[0]} (${winner[1]} votes)`);
    } catch (error) {
      console.log("‚ö†Ô∏è  Impossible d'afficher les r√©sultats:", error.message);
    }
  });

// Commande pour voir les r√©sultats - Version Docker
task("results", "Affiche les r√©sultats de vote")
  .addParam("contract", "Adresse du contrat")
  .addOptionalParam("network", "R√©seau √† utiliser", "hardhat")
  .setAction(async (taskArgs, hre) => {
    console.log(`üê≥ Mode Docker - R√©seau: ${taskArgs.network}`);
    
    try {
      const voting = await hre.ethers.getContractAt("Voting", taskArgs.contract);
      
      console.log("üìä R√©sultats de l'√©lection:");
      console.log("üìç Contrat:", taskArgs.contract);
      console.log("üåê R√©seau:", hre.network.name);
      console.log("üîó Chain ID:", hre.network.config.chainId);
      
      // Test de connectivit√©
      const blockNumber = await hre.ethers.provider.getBlockNumber();
      console.log("üß± Bloc actuel:", blockNumber);
      
      const results = await voting.getCandidates();
      
      if (results[0].length === 0) {
        console.log("‚ùå Aucun candidat trouv√©!");
        return;
      }
      
      let totalVotes = 0;
      results[0].forEach((name, i) => {
        const votes = Number(results[1][i]);
        totalVotes += votes;
        console.log(`   ${name}: ${votes} votes`);
      });
      
      console.log(`\nüìà Total des votes: ${totalVotes}`);
      
      const winner = await voting.getWinner();
      console.log(`\nüèÜ Gagnant: ${winner[0]} avec ${winner[1]} votes`);
      
      // Pourcentages
      if (totalVotes > 0) {
        console.log("\nüìä Pourcentages:");
        results[0].forEach((name, i) => {
          const votes = Number(results[1][i]);
          const percentage = ((votes / totalVotes) * 100).toFixed(1);
          console.log(`   ${name}: ${percentage}%`);
        });
      }
      
      // Informations du contrat
      const candidateCount = await voting.candidateCount();
      console.log(`\nüìã Nombre de candidats: ${candidateCount}`);
      
    } catch (error) {
      if (error.code === 'NETWORK_ERROR') {
        console.log("‚ùå Erreur r√©seau Docker:", error.message);
        console.log("üí° V√©rifications:");
        console.log("   - Le n≈ìud Hardhat est-il d√©marr√© ? (docker-compose ps)");
        console.log("   - L'adresse du contrat est-elle correcte ?");
        console.log("   - Le r√©seau est-il le bon ?");
      } else {
        console.log("‚ùå Erreur lors de la lecture des r√©sultats:", error.message);
      }
    }
  });

// Commande pour d√©ployer avec candidats personnalis√©s - Version Docker
task("deploy-voting", "D√©ploie un contrat de vote")
  .addOptionalParam("candidates", "Candidats s√©par√©s par des virgules", "Alice,Bob,Carol")
  .addOptionalParam("network", "R√©seau √† utiliser", "hardhat")
  .setAction(async (taskArgs, hre) => {
    const candidates = taskArgs.candidates.split(',').map(c => c.trim());
    
    if (candidates.length < 2) {
      console.log("‚ùå Il faut au moins 2 candidats!");
      return;
    }
    
    console.log("üê≥ D√©ploiement Docker du contrat de vote...");
    console.log("üë• Candidats:", candidates);
    console.log("üåê R√©seau:", hre.network.name);
    console.log("üîó Chain ID:", hre.network.config.chainId);
    
    try {
      const [deployer] = await hre.ethers.getSigners();
      console.log("üë§ D√©ployeur:", deployer.address);
      
      // V√©rifier le solde
      const balance = await hre.ethers.provider.getBalance(deployer.address);
      console.log("üí∞ Solde:", hre.ethers.formatEther(balance), "ETH");
      
      // V√©rifier la connectivit√© r√©seau
      const blockNumber = await hre.ethers.provider.getBlockNumber();
      console.log("üß± Bloc actuel:", blockNumber);
      
      const Voting = await hre.ethers.getContractFactory("Voting");
      
      // Estimation du gas
      const deployTransaction = Voting.getDeployTransaction(candidates);
      const gasEstimate = await hre.ethers.provider.estimateGas(deployTransaction);
      console.log("‚õΩ Gas estim√© pour le d√©ploiement:", gasEstimate.toString());
      
      const voting = await Voting.deploy(candidates, {
        gasLimit: gasEstimate * 120n / 100n // 20% de marge
      });
      
      console.log("‚è≥ D√©ploiement en cours...");
      await voting.waitForDeployment();
      
      const address = await voting.getAddress();
      console.log("‚úÖ Contrat d√©ploy√© √†:", address);
      console.log("üó≥Ô∏è  Pr√™t pour le vote!");
      
      // V√©rification post-d√©ploiement
      const deployedCandidates = await voting.getCandidates();
      console.log("\nüìã Candidats confirm√©s:");
      deployedCandidates[0].forEach((name, i) => {
        console.log(`   ${i}: ${name}`);
      });
      
      console.log("\nüí° Commandes pour voter :");
      console.log("üê≥ Avec Docker Compose (RECOMMAND√â) :");
      deployedCandidates[0].forEach((name, i) => {
        console.log(`   docker-compose run --rm hardhat-dev npx hardhat vote --candidate ${i} --contract ${address}  # ${name}`);
      });
      
      console.log("\n‚ö° Depuis l'int√©rieur d'un conteneur :");
      deployedCandidates[0].forEach((name, i) => {
        console.log(`   npx hardhat vote --candidate ${i} --contract ${address}  # ${name}`);
      });
      
      console.log("\nüìä Pour voir les r√©sultats :");
      console.log(`   docker-compose run --rm hardhat-dev npx hardhat results --contract ${address}`);
      
      console.log("\nüß™ Pour simuler plus de votes :");
      console.log(`   docker-compose run --rm hardhat-dev npx hardhat simulate --votes 10`);
      
      return address;
    } catch (error) {
      if (error.code === 'NETWORK_ERROR') {
        console.log("‚ùå Erreur r√©seau Docker lors du d√©ploiement:", error.message);
        console.log("üí° V√©rifiez que le n≈ìud Hardhat est d√©marr√©:");
        console.log("   docker-compose up -d hardhat-dev");
      } else {
        console.log("‚ùå Erreur lors du d√©ploiement:", error.message);
      }
    }
  });

// Commande pour simuler une √©lection compl√®te - Version Docker
task("simulate", "Simule une √©lection compl√®te")
  .addOptionalParam("votes", "Nombre de votes √† simuler", "10")
  .addOptionalParam("candidates", "Candidats personnalis√©s", "Alice,Bob,Carol")
  .addOptionalParam("network", "R√©seau √† utiliser", "hardhat")
  .setAction(async (taskArgs, hre) => {
    const candidates = taskArgs.candidates.split(',').map(c => c.trim());
    const numVotes = parseInt(taskArgs.votes);
    
    console.log("üê≥ Simulation d'√©lection Docker...");
    console.log("üë• Candidats:", candidates);
    console.log("üìä Nombre de votes:", numVotes);
    console.log("üåê R√©seau:", hre.network.name);
    
    try {
      // Test de connectivit√©
      const blockNumber = await hre.ethers.provider.getBlockNumber();
      console.log("üß± Bloc de d√©part:", blockNumber);
      
      // D√©ploiement
      const Voting = await hre.ethers.getContractFactory("Voting");
      const voting = await Voting.deploy(candidates);
      await voting.waitForDeployment();
      const address = await voting.getAddress();
      console.log("üìç Contrat:", address);
      
      // Obtenir des comptes
      const signers = await hre.ethers.getSigners();
      const availableSigners = Math.min(numVotes, signers.length - 1);
      
      if (availableSigners < numVotes) {
        console.log(`‚ö†Ô∏è  Seulement ${availableSigners} comptes disponibles, simulation ajust√©e`);
      }
      
      console.log(`\nüë• ${availableSigners} √©lecteurs vont voter...\n`);
      
      // Votes avec gestion d'erreur Docker
      const votePromises = [];
      const voteDistribution = new Array(candidates.length).fill(0);
      
      for (let i = 0; i < availableSigners; i++) {
        const candidateChoice = Math.floor(Math.random() * candidates.length);
        voteDistribution[candidateChoice]++;
        
        const votePromise = voting.connect(signers[i + 1]).vote(candidateChoice)
          .then(tx => tx.wait())
          .then(() => {
            console.log(`‚úÖ √âlecteur ${i + 1} vote pour ${candidates[candidateChoice]}`);
            return true;
          })
          .catch(error => {
            console.log(`‚ùå √âlecteur ${i + 1} - Erreur:`, error.message);
            return false;
          });
        
        votePromises.push(votePromise);
        
        // R√©sultats partiels tous les 5 votes
        if ((i + 1) % 5 === 0) {
          await Promise.all(votePromises);
          votePromises.length = 0; // Reset
          
          try {
            const partial = await voting.getCandidates();
            console.log(`üìä Apr√®s ${i + 1} votes:`, 
              partial[0].map((name, idx) => `${name}=${partial[1][idx]}`).join(', '));
          } catch (error) {
            console.log("‚ö†Ô∏è  Impossible d'afficher les r√©sultats partiels");
          }
        }
        
        // Petit d√©lai pour √©viter la surcharge r√©seau Docker
        if (i < availableSigners - 1) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }
      
      // Attendre tous les votes restants
      await Promise.all(votePromises);
      
      // Bloc final
      const finalBlockNumber = await hre.ethers.provider.getBlockNumber();
      console.log(`üß± Bloc final: ${finalBlockNumber} (+${finalBlockNumber - blockNumber} blocs)`);
      
      // R√©sultats finaux d√©taill√©s
      console.log("\n" + "=".repeat(60));
      console.log("üèÜ R√âSULTATS FINAUX DE L'√âLECTION DOCKER");
      console.log("=".repeat(60));
      
      const results = await voting.getCandidates();
      const totalVotes = results[1].reduce((sum, votes) => sum + Number(votes), 0);
      
      results[0].forEach((name, i) => {
        const votes = Number(results[1][i]);
        const percentage = totalVotes > 0 ? ((votes / totalVotes) * 100).toFixed(1) : 0;
        console.log(`üìä ${name.padEnd(15)} ${votes} votes (${percentage}%)`);
      });
      
      const winner = await voting.getWinner();
      console.log(`\nüéâ GAGNANT: ${winner[0]} avec ${winner[1]} votes!`);
      console.log(`üìç Contrat: ${address}`);
      console.log(`üåê R√©seau: ${hre.network.name}`);
      console.log(`üê≥ Environment: Docker`);
      
    } catch (error) {
      if (error.code === 'NETWORK_ERROR') {
        console.log("‚ùå Erreur r√©seau Docker lors de la simulation:", error.message);
        console.log("üí° V√©rifiez la connectivit√© Docker");
      } else {
        console.log("‚ùå Erreur lors de la simulation:", error.message);
      }
    }
  });

// Commande sp√©cifique Docker pour v√©rifier la connectivit√©
task("docker-status", "V√©rifie l'√©tat de la connectivit√© Docker")
  .setAction(async (taskArgs, hre) => {
    console.log("üê≥ DIAGNOSTIC DOCKER - Voting DApp");
    console.log("=" * 50);
    
    try {
      // Informations r√©seau
      console.log("üåê R√©seau actuel:", hre.network.name);
      console.log("üîó Chain ID:", hre.network.config.chainId);
      console.log("üì° URL RPC:", hre.network.config.url || "R√©seau int√©gr√©");
      
      // Test de connectivit√©
      console.log("\nüîå Test de connectivit√©...");
      const blockNumber = await hre.ethers.provider.getBlockNumber();
      console.log("‚úÖ Bloc actuel:", blockNumber);
      
      // Informations sur les comptes
      const signers = await hre.ethers.getSigners();
      console.log("üë• Comptes disponibles:", signers.length);
      
      if (signers.length > 0) {
        const balance = await hre.ethers.provider.getBalance(signers[0].address);
        console.log("üí∞ Solde du premier compte:", hre.ethers.formatEther(balance), "ETH");
      }
      
      // Version du n≈ìud
      try {
        const version = await hre.ethers.provider.send("web3_clientVersion", []);
        console.log("üîß Version du n≈ìud:", version);
      } catch (error) {
        console.log("üîß Version du n≈ìud: Non disponible");
      }
      
      console.log("\n‚úÖ Tout semble fonctionner correctement!");
      
    } catch (error) {
      console.log("\n‚ùå PROBL√àME D√âTECT√â:");
      console.log("Erreur:", error.message);
      console.log("\nüí° V√©rifications recommand√©es:");
      console.log("1. docker-compose ps | grep hardhat");
      console.log("2. docker-compose logs hardhat-dev");
      console.log("3. docker-compose restart hardhat-dev");
    }
  });

// Commande d'aide sp√©cifique Docker
task("docker-help", "Affiche l'aide pour les commandes Docker")
  .setAction(async () => {
    console.log("üê≥ COMMANDES DOCKER VOTING DAPP");
    console.log("=" * 60);
    console.log("");
    console.log("üì¶ D√âPLOIEMENT:");
    console.log("   docker-compose run --rm hardhat-dev npx hardhat deploy-voting");
    console.log("   docker-compose run --rm hardhat-dev npx hardhat deploy-voting --candidates 'Jean,Marie'");
    console.log("");
    console.log("üó≥Ô∏è  VOTER:");
    console.log("   docker-compose run --rm hardhat-dev npx hardhat vote --candidate 0 --contract ADRESSE");
    console.log("   docker-compose run --rm hardhat-dev npx hardhat vote --candidate 1 --contract ADRESSE");
    console.log("");
    console.log("üìä R√âSULTATS:");
    console.log("   docker-compose run --rm hardhat-dev npx hardhat results --contract ADRESSE");
    console.log("");
    console.log("üß™ SIMULATION:");
    console.log("   docker-compose run --rm hardhat-dev npx hardhat simulate");
    console.log("   docker-compose run --rm hardhat-dev npx hardhat simulate --votes 20");
    console.log("");
    console.log("üîç DIAGNOSTIC:");
    console.log("   docker-compose run --rm hardhat-dev npx hardhat docker-status");
    console.log("   docker-compose ps");
    console.log("   docker-compose logs hardhat-dev");
    console.log("");
    console.log("üí° R√âSEAUX DISPONIBLES:");
    console.log("   --network hardhat   (par d√©faut, r√©seau int√©gr√©)");
    console.log("   --network docker    (communication inter-conteneurs)");
    console.log("   --network localhost (connexion externe)");
    console.log("   --network ganache   (si Ganache activ√©)");
    console.log("");
    console.log("üöÄ D√âMARRAGE RAPIDE:");
    console.log("   docker-compose up -d hardhat-dev");
    console.log("   docker-compose run --rm hardhat-dev npx hardhat deploy-voting");
    console.log("   # Utilisez l'adresse retourn√©e pour voter");
  });